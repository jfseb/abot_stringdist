{"version":3,"sources":["/projects/nodejs/botbuilder/abot_stringdist/src/../src/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["'use strict'\r\n\r\n// based on: http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Levenshtein_distance\r\n// and:  http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance\r\n\r\n\r\n/**\r\n * Distance of strings algorithm\r\n * @module fsdevstart.utils.damerauLevenshtein\r\n */\r\n\r\n/**\r\n * a function calculating distance between two strings\r\n * according to the damerau Levenshtein algorithm\r\n * (this algorithm, in contrast to plain levenshtein treats\r\n * swapping of characters a distance 1  \"word\"  <-> \"wrod )\r\n * @param {string} a\r\n * @param {string} b\r\n * @public\r\n */\r\n\r\n\r\n/*\r\nexport function levenshteinDamerau (a : string, b : string) {\r\n  var i : number\r\n  var j : number\r\n  var cost : number\r\n  var d = []\r\n  if (a.length === 0) {\r\n    return b.length\r\n  }\r\n  if (b.length === 0) {\r\n    return a.length\r\n  }\r\n  for (i = 0; i <= a.length; i++) {\r\n    d[ i ] = []\r\n    d[ i ][ 0 ] = i\r\n  }\r\n  for (j = 0; j <= b.length; j++) {\r\n    d[ 0 ][ j ] = j\r\n  }\r\n  for (i = 1; i <= a.length; i++) {\r\n    for (j = 1; j <= b.length; j++) {\r\n      if (a.charAt(i - 1) === b.charAt(j - 1)) {\r\n        cost = 0\r\n      } else {\r\n        cost = 1\r\n      }\r\n\r\n      d[ i ][ j ] = Math.min(d[ i - 1 ][ j ] + 1, d[ i ][ j - 1 ] + 1, d[ i - 1 ][ j - 1 ] + cost)\r\n\r\n      if (\r\n\r\n        i > 1 &&\r\n\r\n        j > 1 &&\r\n\r\n        a.charAt(i - 1) === b.charAt(j - 2) &&\r\n\r\n        a.charAt(i - 2) === b.charAt(j - 1)\r\n\r\n      ) {\r\n        d[i][j] = Math.min(\r\n\r\n          d[i][j],\r\n\r\n          d[i - 2][j - 2] + cost\r\n\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  return d[ a.length ][ b.length ]\r\n}\r\n*/\r\n\r\n/*\r\nexport function levenshtein (a : string, b : string) {\r\n  //return 2.0 * sift3Distance(a,b); //,6,7); // + b.length / 2);\r\n  return levenshteinDamerau(a,b);\r\n}\r\n*/\r\n\r\n\r\n/*\r\n\r\nexport function sift3Distance(s1, s2) {\r\n    if (s1 == null || s1.length === 0) {\r\n        if (s2 == null || s2.length === 0) {\r\n            return 0;\r\n        } else {\r\n            return s2.length;\r\n        }\r\n    }\r\n\r\n    if (s2 == null || s2.length === 0) {\r\n        return s1.length;\r\n    }\r\n    if (Math.abs(s1.length  - s2.length) > 20) {\r\n      return  Math.max(s1.length, s2.length)/2;\r\n    }\r\n\r\n    var c = 0;\r\n    var offset1 = 0;\r\n    var offset2 = 0;\r\n    var lcs = 0;\r\n    var maxOffset = 3;\r\n\r\n    while ((c + offset1 < s1.length) && (c + offset2 < s2.length)) {\r\n        if (s1.charAt(c + offset1) == s2.charAt(c + offset2)) {\r\n            lcs++;\r\n        } else {\r\n            offset1 = 0;\r\n            offset2 = 0;\r\n            for (var i = 0; i < maxOffset; i++) {\r\n                if ((c + i < s1.length) && (s1.charAt(c + i) == s2.charAt(c))) {\r\n                    offset1 = i;\r\n                    break;\r\n                }\r\n                if ((c + i < s2.length) && (s1.charAt(c) == s2.charAt(c + i))) {\r\n                    offset2 = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        c++;\r\n    }\r\n    return (s1.length + s2.length) / 2 - lcs;\r\n}\r\n*/\r\n\r\n/*\r\n//  Sift4 - common version\r\n// https://siderite.blogspot.com/2014/11/super-fast-and-accurate-string-distance.html\r\n// online algorithm to compute the distance between two strings in O(n)\r\n// maxOffset is the number of characters to search for matching letters\r\n// maxDistance is the distance at which the algorithm should stop computing the value and just exit (the strings are too different anyway)\r\nexport function sift4(s1, s2, maxOffset, maxDistance) {\r\n    if (!s1||!s1.length) {\r\n        if (!s2) {\r\n            return 0;\r\n        }\r\n        return s2.length;\r\n    }\r\n\r\n    if (!s2||!s2.length) {\r\n        return s1.length;\r\n    }\r\n\r\n    var l1=s1.length;\r\n    var l2=s2.length;\r\n    if(Math.abs(l1 - l2) > maxDistance) {\r\n      return 50000;\r\n    }\r\n\r\n    var c1 = 0;  //cursor for string 1\r\n    var c2 = 0;  //cursor for string 2\r\n    var lcss = 0;  //largest common subsequence\r\n    var local_cs = 0; //local common substring\r\n    var trans = 0;  //number of transpositions ('ab' vs 'ba')\r\n    var offset_arr=[];  //offset pair array, for computing the transpositions\r\n\r\n    while ((c1 < l1) && (c2 < l2)) {\r\n        if (s1.charAt(c1) == s2.charAt(c2)) {\r\n            local_cs++;\r\n            var isTrans=false;\r\n            //see if current match is a transposition\r\n            var i=0;\r\n            while (i<offset_arr.length) {\r\n                var ofs=offset_arr[i];\r\n                if (c1<=ofs.c1 || c2 <= ofs.c2) {\r\n                    // when two matches cross, the one considered a transposition is the one with the largest difference in offsets\r\n                    isTrans=Math.abs(c2-c1)>=Math.abs(ofs.c2-ofs.c1);\r\n                    if (isTrans)\r\n                    {\r\n                        trans++;\r\n                    } else\r\n                    {\r\n                        if (!ofs.trans) {\r\n                            ofs.trans=true;\r\n                            trans++;\r\n                        }\r\n                    }\r\n                    break;\r\n                } else {\r\n                    if (c1>ofs.c2 && c2>ofs.c1) {\r\n                        offset_arr.splice(i,1);\r\n                    } else {\r\n                        i++;\r\n                    }\r\n                }\r\n            }\r\n            offset_arr.push({\r\n                c1:c1,\r\n                c2:c2,\r\n                trans:isTrans\r\n            });\r\n        } else {\r\n            lcss+=local_cs;\r\n            local_cs=0;\r\n            if (c1!=c2) {\r\n                c1=c2=Math.min(c1,c2);  //using min allows the computation of transpositions\r\n            }\r\n            //if matching characters are found, remove 1 from both cursors (they get incremented at the end of the loop)\r\n            //so that we can have only one code block handling matches\r\n            for (var i = 0; i < maxOffset && (c1+i<l1 || c2+i<l2); i++) {\r\n                if ((c1 + i < l1) && (s1.charAt(c1 + i) == s2.charAt(c2))) {\r\n                    c1+= i-1;\r\n                    c2--;\r\n                    break;\r\n                }\r\n                if ((c2 + i < l2) && (s1.charAt(c1) == s2.charAt(c2 + i))) {\r\n                    c1--;\r\n                    c2+= i-1;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        c1++;\r\n        c2++;\r\n        if (maxDistance)\r\n        {\r\n            var temporaryDistance=Math.max(c1,c2)-lcss+trans;\r\n            if (temporaryDistance>=maxDistance) return 50000; // Math.round(temporaryDistance);\r\n        }\r\n        // this covers the case where the last match is on the last token in list, so that it can compute transpositions correctly\r\n        if ((c1 >= l1) || (c2 >= l2)) {\r\n            lcss+=local_cs;\r\n            local_cs=0;\r\n            c1=c2=Math.min(c1,c2);\r\n        }\r\n    }\r\n    lcss+=local_cs;\r\n    return Math.round(Math.max(l1,l2)- lcss +trans); //add the cost of transpositions to the final result\r\n}\r\n\r\n*/\r\n\r\n/**\r\n * Talisman metrics/distance/jaro\r\n * ===============================\r\n *\r\n * Function computing the Jaro score.\r\n *\r\n * [Reference]:\r\n * https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance\r\n *\r\n * [Articles]:\r\n * Jaro, M. A. (1989). \"Advances in record linkage methodology as applied to\r\n * the 1985 census of Tampa Florida\".\r\n * Journal of the American Statistical Association 84 (406): 414–20\r\n *\r\n * Jaro, M. A. (1995). \"Probabilistic linkage of large public health data file\".\r\n * Statistics in Medicine 14 (5–7): 491–8.\r\n *\r\n * [Tags]: semimetric, string metric.\r\n */\r\n\r\n\r\n/**\r\n * Function creating a vector of n dimensions and filling it with a single\r\n * value if required.\r\n *\r\n * @param  {number} n    - Dimensions of the vector to create.\r\n * @param  {mixed}  fill - Value to be used to fill the vector.\r\n * @return {array}       - The resulting vector.\r\n */\r\nexport function vec(n, fill) {\r\n  const vector = new Array(n);\r\n\r\n  if (arguments.length > 1) {\r\n    for (let i = 0; i < n; i++)\r\n      vector[i] = fill;\r\n  }\r\n  return vector;\r\n}\r\n\r\n\r\n/**\r\n * Function returning the Jaro score between two sequences.\r\n *\r\n * @param  {mixed}  a     - The first sequence.\r\n * @param  {mixed}  b     - The second sequence.\r\n * @return {number}       - The Jaro score between a & b.\r\n */\r\nexport function talisman_jaro(a, b) {\r\n  // Fast break\r\n  if (a === b)\r\n    return 1;\r\n\r\n  let max, min;\r\n\r\n  if (a.length > b.length) {\r\n    max = a;\r\n    min = b;\r\n  }\r\n  else {\r\n    max = b;\r\n    min = a;\r\n  }\r\n\r\n  // Finding matches\r\n  const range = Math.max(((max.length / 2) | 0) - 1, 0),\r\n        indexes = vec(min.length, -1),\r\n        flags = vec(max.length, false);\r\n\r\n  let matches = 0;\r\n\r\n  for (let i = 0, l = min.length; i < l; i++) {\r\n    const character = min[i],\r\n          xi = Math.max(i - range, 0),\r\n          xn = Math.min(i + range + 1, max.length);\r\n\r\n    for (let j = xi, m = xn; j < m; j++) {\r\n      if (!flags[j] && character === max[j]) {\r\n        indexes[i] = j;\r\n        flags[j] = true;\r\n        matches++;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  const ms1 = new Array(matches),\r\n        ms2 = new Array(matches);\r\n\r\n  let si;\r\n\r\n  si = 0;\r\n  for (let i = 0, l = min.length; i < l; i++) {\r\n    if (indexes[i] !== -1) {\r\n      ms1[si] = min[i];\r\n      si++;\r\n    }\r\n  }\r\n\r\n  si = 0;\r\n  for (let i = 0, l = max.length; i < l; i++) {\r\n    if (flags[i]) {\r\n      ms2[si] = max[i];\r\n      si++;\r\n    }\r\n  }\r\n\r\n  let transpositions = 0;\r\n  for (let i = 0, l = ms1.length; i < l; i++) {\r\n    if (ms1[i] !== ms2[i])\r\n      transpositions++;\r\n  }\r\n\r\n  // Computing the distance\r\n  if (!matches)\r\n    return 0;\r\n\r\n  const t = (transpositions / 2) | 0,\r\n        m = matches;\r\n\r\n  return ((m / a.length) + (m / b.length) + ((m - t) / m)) / 3;\r\n}\r\n\r\n/**\r\n * Jaro distance is 1 - the Jaro score.\r\n */\r\n//const distance = (a, b) => 1 - jaro(a, b);\r\n\r\n\r\n\r\n\r\n/**\r\n * Talisman metrics/distance/jaro-winkler\r\n * =======================================\r\n *\r\n * Function computing the Jaro-Winkler score.\r\n *\r\n * [Reference]:\r\n * https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance\r\n *\r\n * [Article]:\r\n * Winkler, W. E. (1990). \"String Comparator Metrics and Enhanced Decision Rules\r\n * in the Fellegi-Sunter Model of Record Linkage\".\r\n * Proceedings of the Section on Survey Research Methods\r\n * (American Statistical Association): 354–359.\r\n *\r\n * [Tags]: semimetric, string metric.\r\n */\r\n\r\n/**\r\n * Jaro-Winkler standard function.\r\n */\r\n//export const jaroWinkler = customJaroWinkler.bind(null, null);\r\n\r\n/**\r\n * Jaro-Winkler distance is 1 - the Jaro-Winkler score.\r\n */\r\n//const distance = (a, b) => 1 - jaroWinkler(a, b);\r\n\r\n/**\r\n * Exporting.\r\n */\r\n\r\n\r\n// Computes the Winkler distance between two string -- intrepreted from:\r\n// http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance\r\n// s1 is the first string to compare\r\n// s2 is the second string to compare\r\n// dj is the Jaro Distance (if you've already computed it), leave blank and the method handles it\r\nexport function jaroWinklerDistance(s1 : string, s2: string) {\r\n\t\tif (s1 == s2) {\r\n\t\t\t\treturn 1\r\n\t\t}\r\n\t\telse {\r\n\t\t    var jaro = talisman_jaro(s1,s2);\r\n        var p = 0.1; //\r\n\t\t    var l = 0 // length of the matching prefix\r\n\t\t    while(s1[l] == s2[l] && l < 4)\r\n\t\t        l++;\r\n\r\n\t\t    return jaro + l * p * (1 - jaro);\r\n\t\t}\r\n}\r\n\r\n/*\r\n\r\nfunction cntChars(str : string, len : number) {\r\n  var cnt = 0;\r\n  for(var i = 0; i < len; ++i) {\r\n    cnt += (str.charAt(i) === 'X')? 1 : 0;\r\n  }\r\n  return cnt;\r\n}\r\n*/\r\n\r\n/**\r\n * @param sText {string} the text to match to NavTargetResolution\r\n * @param sText2 {string} the query text, e.g. NavTarget\r\n *\r\n * @return the distance, note that is is *not* symmetric!\r\n */\r\nexport function calcDistance(sText1: string, sText2: string): number {\r\n  // console.log(\"length2\" + sText1 + \" - \" + sText2)\r\n  var s1len = sText1.length;\r\n  var s2len = sText2.length;\r\n  var min = Math.min(s1len,s2len);\r\n  if(Math.abs(s1len - s2len) > min) {\r\n    return 0.3;\r\n  }\r\n  var dist = jaroWinklerDistance(sText1,sText2);\r\n  /*\r\n  var cnt1 = cntChars(sText1, s1len);\r\n  var cnt2 = cntChars(sText2, s2len);\r\n  if(cnt1 !== cnt2) {\r\n    dist = dist * 0.7;\r\n  }\r\n  */\r\n  return dist;\r\n  /*\r\n  var a0 = distance.levenshtein(sText1.substring(0, sText2.length), sText2)\r\n  if(debuglogV.enabled) {\r\n    debuglogV(\"distance\" + a0 + \"stripped>\" + sText1.substring(0,sText2.length) + \"<>\" + sText2+ \"<\");\r\n  }\r\n  if(a0 * 50 > 15 * sText2.length) {\r\n      return 40000;\r\n  }\r\n  var a = distance.levenshtein(sText1, sText2)\r\n  return a0 * 500 / sText2.length + a\r\n  */\r\n}\r\n\r\n/*\r\nvar facAdjustDistance = [];\r\nvar u = \"a\";\r\nfor(var i = 2; i < 15; ++i) {\r\n  var un = u + String.fromCharCode('A'.charCodeAt(0) + i + 1 );\r\n  console.log(un);\r\n  facAdjustDistance[u.length] = (1-0.9801000)/ (1.0 - calcDistance(u,un));\r\n  u = un;\r\n}\r\n\r\nexport function calcDistanceAdjusted2(a: string, b:string) : number {\r\n  var dist = calcDistance(a,b);\r\n  var ml = Math.min(a.length, b.length);\r\n  if(dist < 1.0 && (ml < 15) &&  (ml > 2)) {\r\n      return 1.0  -  (1.0- dist) * facAdjustDistance[ml];\r\n  }\r\n  return dist;\r\n}\r\n*/\r\n\r\n/**\r\n * The adjustment is chosen in the following way,\r\n * a single \"added\" character at the end of the string fits\r\n * is \"lifted at length 5\" to 0.98\r\n *   1.665 =  ( 1 - calcDistance('abcde','abcde_')) / 0.98\r\n *\r\n * The function is smoothly to merge at length 20;\r\n *   fac =((20-len)/(15))*0.665 +1\r\n *   res = 1- (1-d)/fac;\r\n */\r\n\r\n\r\n\r\nexport function calcDistanceAdjusted(a: string, b:string) : number {\r\n  var dist = calcDistance(a,b);\r\n  var ml = Math.min(a.length, b.length);\r\n  if(dist < 1.0 && (ml < 20)) {\r\n      var fac =  1 + (0.665/15.0)*(20-ml);\r\n      return 1.0  -  (1.0 - dist) /fac;\r\n  }\r\n  return dist;\r\n}\r\n\r\n/*\r\n\r\nfunction getCharAt(str, n) {\r\n  if(str.length > n) {\r\n    return str.charAt(n);\r\n  }\r\n  return '';\r\n}\r\n\r\nfunction getHead(str,u) {\r\n  u = Math.min(str.length, u);\r\n  u = Math.max(0,u);\r\n  return str.substring(0,u);\r\n}\r\n\r\nfunction getTail(str,p) {\r\n  return str.substring(p);\r\n}\r\n\r\nvar strs = [\"A\"];\r\nvar u = \"A\";\r\nfor(var i = 1; i < 25; ++i) {\r\n  var un = u + String.fromCharCode('A'.charCodeAt(0) + i );\r\n  strs[un.length-1] = un;\r\n  console.log(un);\r\n  facAdjustDistance[u.length] = (1-0.9801000)/ (1.0 - calcDistance(u,un));\r\n  u = un;\r\n}\r\n\r\nvar res = [];\r\n\r\nvar res2 = [];\r\nfor(var i = 1; i < strs.length; ++i) {\r\n  var str = strs[i];\r\n  var nc = String.fromCharCode('a'.charCodeAt(0) + 2*i + 2 );\r\n  var nc = '_';\r\n  var addTail = str  + nc;\r\n  var addFront = nc + str;\r\n  var nc2 = '/'; //String.fromCharCode('a'.charCodeAt(0) + 2*i + 3 );\r\n\r\n  var diffMid = getHead(str,Math.floor(str.length/2))  + nc  + getTail(str, Math.floor(str.length/2)+1);\r\n  var diffMid2 = strs[i].substring(0, Math.floor(str.length/2)-1) + nc + nc2 + getTail(str,Math.floor(str.length/2)+1);\r\n  var diffEnd = strs[i].substring(0, strs[i].length - 1) + nc;\r\n  var diffStart = nc + strs[i].substring(1);\r\n  var swapFront = str.substring(0,2) + getCharAt(str,3) + getCharAt(str,2) + str.substring(4);\r\n  var swapMid = getHead(str, Math.floor(str.length/2)-1)  + getCharAt(str,Math.floor(str.length/2)) + getCharAt(str,Math.floor(str.length/2)-1)  + getTail(str,Math.floor(str.length/2)+1);\r\n  var swapEnd = getHead(str, str.length - 2) + getCharAt(str,str.length-1) + getCharAt(str,str.length-2);\r\n\r\n  var r = [diffStart, diffMid, diffEnd, addFront, addTail, diffMid2, swapFront, swapMid, swapEnd ];\r\n  console.log('****\\n' + str +'\\n' + r.join(\"\\n\"));\r\n  if( i === 1) {\r\n    res.push(`i\\tdiffStart\\tdiffMid\\tdiffEnd\\taddFront\\taddTail\\tdiffMid2\\tswapFront\\tswapMid\\tswapEnd\\n`);\r\n    res2.push(`i\\tdiffStart\\tdiffMid\\tdiffEnd\\taddFront\\taddTail\\tdiffMid2\\tswapFront\\tswapMid\\tswapEnd\\n`);\r\n  }\r\n  res.push(`${str.length}\\t` + r.map(s => calcDistance(str,s).toFixed(4)).join(\"\\t\") + '\\n');\r\n  res2.push(`${str.length}\\t` + r.map(s => calcDistanceAdjusted(str,s).toFixed(4)).join(\"\\t\") + '\\n');\r\n}\r\n\r\n\r\nconsole.log(res.join(''));\r\n\r\nconsole.log('---');\r\nconsole.log(res2.join(''));\r\n\r\nvar fs = require('fs');\r\nfs.writeFileSync('leven.txt', res.join('') + '\\n' + res2.join(''));\r\n\r\n*/\r\n\r\n\r\n\r\n\r\n"],"sourceRoot":"ABC"}